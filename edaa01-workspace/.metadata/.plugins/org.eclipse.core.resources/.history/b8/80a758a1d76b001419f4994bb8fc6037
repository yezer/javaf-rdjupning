package bst;

public class BinarySearchTree<E extends Comparable<? super E>> {
	BinaryNode<E> root;
	int size;

	/**
	 * Constructs an empty binary searchtree.
	 */
	public BinarySearchTree() {
	}

	public static void main(String[] args) {
		// First tree
		BinarySearchTree<Integer> myTree = new BinarySearchTree<Integer>();
		myTree.add(8);
		myTree.add(8);
		myTree.add(6);
		myTree.add(2);
		myTree.add(15);
		System.out.println("The height of my tree is " + myTree.height());
		System.out.println("The size of my tree is " + myTree.size());
		myTree.printTree();
		BSTVisualizer visualizer = new BSTVisualizer("My First Tree", 300, 400);
		visualizer.drawTree(myTree);

		// Second tree
		BinarySearchTree<Integer> mySecondTree = new BinarySearchTree<Integer>();
		mySecondTree.add(6);
		mySecondTree.add(8);
		mySecondTree.add(2);
		mySecondTree.add(3);
		mySecondTree.add(690);
		mySecondTree.add(4);
		mySecondTree.add(98);
		mySecondTree.add(66);
		mySecondTree.add(500);
		mySecondTree.add(709);
		System.out.println("The height of my second tree is "
				+ mySecondTree.height());
		System.out.println("The size of my second tree is "
				+ mySecondTree.size());
		mySecondTree.printTree();
		BSTVisualizer visualizer2 = new BSTVisualizer("My Second Tree", 300,
				400);
		visualizer2.drawTree(mySecondTree);

		// Third tree
		BinarySearchTree<Integer> myThirdTree = new BinarySearchTree<Integer>();
		myThirdTree.add(78);
		myThirdTree.add(5);
		myThirdTree.add(9);
		myThirdTree.add(42);
		myThirdTree.add(94);
		myThirdTree.add(34);
		myThirdTree.add(7);
		myThirdTree.add(100);
		myThirdTree.add(83);
		myThirdTree.add(99);
		myThirdTree.add(86);
		myThirdTree.add(42);
		System.out.println("The height of my third tree is "
				+ myThirdTree.height());
		System.out
				.println("The size of my third tree is " + myThirdTree.size());
		myThirdTree.printTree();
		BSTVisualizer visualizer3 = new BSTVisualizer("My Third Tree", 300, 400);
		visualizer3.drawTree(myThirdTree);

		// Rebuild
		mySecondTree.rebuild();
		BSTVisualizer visualizer4 = new BSTVisualizer("My Rebuilt Tree", 300,
				400);
		visualizer4.drawTree(mySecondTree);
	}

	/**
	 * Inserts the specified element in the tree if no duplicate exists.
	 * 
	 * @param x
	 *            element to be inserted
	 * @return true if the the element was inserted
	 */
	public boolean add(E x) {
		if (root == null) {
			root = new BinaryNode<E>(x);
			return true;
		} else {
			return add(root, x);
		}
	}

	private boolean add(BinaryNode<E> n, E x) {
		int compResult = x.compareTo(n.element);
		if (compResult == 0) {
			return false;
		}
		if (compResult < 0) {
			if (n.left == null) {
				n.left = new BinaryNode<E>(x);
				return true;
			} else {
				return add(n.left, x);
			}
		} else {
			if (n.right == null) {
				n.right = new BinaryNode<E>(x);
				return true;
			} else {
				return add(n.right, x);
			}
		}
	}

	/**
	 * Computes the height of tree.
	 * 
	 * @return the height of the tree
	 */
	public int height() {
		return helpHeight(root);
	}

	private int helpHeight(BinaryNode<E> node) {
		int height;
		if (node == null) {
			return 0;
		}
		BinaryNode<E> left = node.left;
		BinaryNode<E> right = node.right;
		int leftTreeHeight = helpHeight(left); // går sedan igenom koden nedan
												// för värdet på leftTreeHeight
												// efter varje return call
		int rightTreeHeight = helpHeight(right);
		if (leftTreeHeight <= rightTreeHeight) {
			height = 1 + rightTreeHeight;
		} else {
			height = 1 + leftTreeHeight;
		}
		return height;
	}

	/**
	 * Returns the number of elements in this tree.
	 * 
	 * @return the number of elements in this tree
	 */
	public int size() {
		return helpSize(root);
	}

	private int helpSize(BinaryNode<E> node) {
		int size;
		if (node == null) {
			return 0;
		}
		BinaryNode<E> left = node.left;
		BinaryNode<E> right = node.right;
		int leftTreeSize = helpSize(left);
		int rightTreeSize = helpSize(right);
		size = 1 + leftTreeSize + rightTreeSize;
		return size;
	}

	/**
	 * Print tree contents in inorder.
	 */
	public void printTree() {
		if (root != null) {
			if (root.left != null) {
				root.left.print();
			}
			System.out.println(root.element);
			if (root.right != null) {
				root.right.print();
			}
		}
	}

	/**
	 * Builds a complete tree from the elements in the tree.
	 */
	public void rebuild() {
		E[] myArray = (E[]) new Comparable[helpSize(root)];
		System.out.println("These are my values for the ascending array");
		int index;
		if(root.left != null){
		index = helpToArray(root, myArray, 0); 
		}
		if(root != null) {
		myArray[index] = root.element;
		}
		if(root.right != null) {
		helpToArray(root, myArray, index+1);
		}
		
	}
		
		
		
		
	/*	int arraySize = toArray(root, myArray, 0);
		for (int i = 0; i < helpSize(root); i++) {
			System.out.println(myArray[i]); */
		}
		// buildTree(myArray, 0, helpSize(root));
	

	/*
	 * Adds all elements from the tree rooted at n in inorder (ascending order)
	 * to the array a starting at a[index]. Returns the index of the last
	 * inserted element + 1 (the first empty position in a).
	 */
/*	private int toArray(BinaryNode<E> n, E[] a, int index) {
		if (n == null) {
			return index;
		}
		a[index] = n.element;
		index = toArray(n.left, a, index + 1);
		index = toArray(n.right, a, index);
		return index;
	} */
	
/*	private int toArray(BinaryNode<E> n, E[] a, int index) {
		BinaryNode<E> root = n;
		if(n.left != null){
			index = helpToArray(n, a, index);
		}
		a[index] = root.element;
		if(n.right != null){
			index = helpToArray(n, a, index);
		}
		return index+1;
	} */
		

		private int helpToArray(BinaryNode<E> n, E[] a, int index) {
			if(n.left != null) {
				n = n.left;
				a[index] = n.element;
				helpToArray(n, a, index+1);
				if(n.right != null) {
					n = n.right;
				}
				return index+1;
		}
		
		
		
		
		for (int i = 0; i < (int)Math.floor(a.length-1)/2; i++) {
			a[i] = n.element;
			i++;
			if (n.left != null) {
				n = n.left;
				a[i] = n.element;
				i++;
			} else {
				if (n.right !=null) {
					n = n.right;
					a[i] = n.element;
					i++;
				}
			}
		a[index] = root.element;	
		n = n.right;	
		for ( i = (int)Math.floor(a.length-1)/2+2; i < a.length-1; i++) {
			a[index] = n.element;
			if (n.left != null) {
				n = n.left;
				a[index] = n.element;
			} else {
				if (n.right !=null) {
					n = n.right;
					a[index] = n.element;
				}
			}
		}
		}
		return index;
	}


	/*
	 * Builds a complete tree from the elements a[first]..a[last]. Elements in
	 * the array a are assumed to be in ascending order. Returns the root of
	 * tree.
	 */
	private BinaryNode<E> buildTree(E[] a, int first, int last) {
		int size = helpSize(root);
		int middle = Math.round(size / 2);
		add(a[middle]);
		for (int i = 0; i < middle; i++) {
			add(a[i]);
		}
		for (int i = middle + 1; i == size - 1; i++) {
			add(a[i]);
		}
		return root;
	}

	static class BinaryNode<E> {
		E element;
		BinaryNode<E> left;
		BinaryNode<E> right;

		private BinaryNode(E element) {
			this.element = element;
		}

		private void print() {
			if (left != null) {
				left.print();
			}
			System.out.println(element);
			if (right != null) {
				right.print();
			}
		}
	}
}

